# -*- coding: utf-8 -*-
"""vipashapy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fco9r6IsBxPFNmxWMer6qBn9Eu7DBL71
"""

import numpy as np
import time as t
a=np.identity(10000)
b=np.identity(10000)
start = t.time()
print(a)
print(b)
c=a+b
print(c)
end=t.time()
net=end-start
print(net)

"""Write a code which:

Loads an image using opencv or PIL.<br>
Convert the loaded image to numpy array.<br>
Display the image using matplotlib (use the .imshow() method)<br>
Take a 20 x 20 crop from anywhere in the image.
Display the cropped image.
"""

from PIL import Image
# Open the image form working directory
image = Image.open('/content/371afa7e0bb2981e1ce3fa750859780d.jpg')
# summarize some details about the image
print(image.format)
print(image.size)
print(image.mode)
# show the image
image.show()

from matplotlib import image
from matplotlib import pyplot
# load image as pixel array
image = image.imread('/371afa7e0bb2981e1ce3fa750859780d.jpg')
# summarize shape of the pixel array
print(image.dtype)
print(image.shape)
# display the array of pixels as an image
pyplot.imshow(image)
pyplot.show()

from PIL import Image
from numpy import asarray
# load the image
image = Image.open('/content/371afa7e0bb2981e1ce3fa750859780d.jpg')
# convert image to numpy array
data = asarray(image)
print(type(data))
# summarize shape
print(data.shape)

# create Pillow image
image2 = Image.fromarray(data)
print(type(image2))

# summarize image details
print(image2.mode)
print(image2.size)
print(data)

from PIL import Image 
from matplotlib import pyplot
# Opens a image in RGB mode 
im = Image.open(r"/content/371afa7e0bb2981e1ce3fa750859780d.jpg") 
  
# Size of the image in pixels (size of orginal image) 
# (This is not mandatory) 
width, height = im.size 
  
# Setting the points for cropped image 
left = 100
top = height / 4
right = 300
bottom = 3 * height / 4
  
# Cropped image of above dimension 
# (It will not change orginal image) 
im1 = im.crop((left, top, right, bottom)) 
  
# Shows the image in image viewer 
pyplot.imshow(im1)
pyplot.show()

import sys
from PIL import Image
from matplotlib import pyplot
images = [Image.open(x) for x in ['Test1.jpg', 'Test2.jpg', 'Test3.jpg']]
widths, heights = zip(*(i.size for i in images))

total_width = sum(widths)
max_height = max(heights)

new_im = Image.new('RGB', (total_width, max_height))

x_offset = 0
for im in images:
  new_im.paste(im, (x_offset,0))
  x_offset += im.size[0]

new_im.save('test.jpg')
pyplot.imshow(new_im)
pyplot.show()

import numpy as np
import PIL
from PIL import Image
from matplotlib import pyplot
list_im = ['Test1.jpg', 'Test2.jpg', 'Test3.jpg']
imgs    = [ PIL.Image.open(i) for i in list_im ]
# pick the image which is the smallest, and resize the others to match it (can be arbitrary image shape here)
min_shape = sorted( [(np.sum(i.size), i.size ) for i in imgs])[0][1]
imgs_comb = np.hstack( (np.asarray( i.resize(min_shape) ) for i in imgs ) )

# save that beautiful picture
imgs_comb = PIL.Image.fromarray( imgs_comb)
imgs_comb.save( 'Trifecta.jpg' )    

# for a vertical stacking it is simple: use vstack
imgs_comb = np.vstack( (np.asarray( i.resize(min_shape) ) for i in imgs ) )
imgs_comb = PIL.Image.fromarray( imgs_comb)
imgs_comb.save( 'Trifecta_vertical.jpg' )
pyplot.imshow(imgs_comb)
pyplot.show()

import numpy as np
import matplotlib.pyplot as plt

def concat_images(imga, imgb):
    """
    Combines two color image ndarrays side-by-side.
    """
    ha,wa = imga.shape[:2]
    hb,wb = imgb.shape[:2]
    max_height = np.max([ha, hb])
    total_width = wa+wb
    new_img = np.zeros(shape=(max_height, total_width, 3))
    new_img[:ha,:wa]=imga
    new_img[:hb,wa:wa+wb]=imgb
    return new_img

def concat_n_images(image_path_list):
    """
    Combines N color images from a list of image paths.
    """
    output = None
    for i, img_path in enumerate(image_path_list):
        img = plt.imread(img_path)[:,:,:3]
        if i==0:
            output = img
        else:
            output = concat_images(output, img)
    return output

images = ["Test1.jpg", "Test2.jpg", "Test3.jpg", "Test1.jpg"]
output = concat_n_images(images)
import matplotlib.pyplot as plt
plt.imshow(output)
 plt.show()

from PIL import Image
import matplotlib.pyplot as plt
import numpy as np
w,h=512,512     # Declared the Width and Height of an Image
t=(h,w,3)       # To store pixels
# Creation of Array
A=np.zeros(t,dtype=np.uint8) 
for i in range(h):
    for j in range(w):
        A[i,j]=[i%256,j%256,(i+j)%256]    # Assigning Colors to Each pixel
i=Image.fromarray(A,"RGB")
i.show()
pyplot.imshow(i)
pyplot.show()

from pylab import imshow, show, get_cmap
from numpy import random

Z = random.random((50,50))   # Test data

imshow(Z, cmap=get_cmap("Spectral"), interpolation='nearest')
show()

import pylab as plt
import numpy as np

Z = np.random.random((500,500))   # Test data
plt.imshow(Z, cmap='gray', interpolation='nearest')
plt.show()

!pip install -q matplotlib-venn

!apt-get -qq install -y libfluidsynth1

import matplotlib.pyplot as plt
import numpy as np
import cv2
img = cv2.imread('Test1.jpg') 
plt.imshow(img)

noise = np.random.normal(0,1,size=(img.shape))
plt.imshow(noise)

strength = 200
nois  = img + strength * noise
plt.imshow( nois.astype('int') )